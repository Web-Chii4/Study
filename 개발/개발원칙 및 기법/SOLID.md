# SOLID원칙

solid원칙은 로버트 C 마틴이 **객체지향 프로그래밍 및 설계**의 다섯가지 기본 원칙을 제시했다.

## SOLID원칙의 사용 이유는 무엇인가?

### 1. 변경에 유연한 구조

프로그램은 고객의 요구사항이나 오류 등의 이유로 변경되는 경우가 많다. 이러한 상황이 발생할 때 기능을 추가하거나 기존의 코드를 수정해야 한다.

**결합도는 낮고 응집도는 높은 구조로** 객체의 구조를 잡을 수 있도록 해야한다.

**응집도)**

<aside>
💡

하나의 모듈이나 **객체가 얼마나 밀접하게 관련된 역할을 수행하는 가**를 의미한다.

</aside>

### 2. 이해하기 쉬운 구조

이해하기 쉬운 구조라 함은 가독성이 좋다 라고 말할 수 있다. 이해하기 쉬운 구조를 프로그램이 가질 수 있도록 Solid원칙을 준수하면 된다.

## 1. Single Responsibility Principle(단일 책임 원칙)

단일 책임 원칙은 객체는 하나의 책임만 가져야 한다는 것이다. 하나의 책임은 하나의 역할을 해야 한다는 것이다.

책임의 범주는 사람마다 규정하기는 다를 수 있지만, SRP에서 말하는 **책임의 범주는 하나의 모듈이 변경될 때 변경의 사유가 단 하나 이어야 한다는 것**이다.

책임을 하나만 가지도록 하면 객체의 응집도가 높아지는 효과가 생긴다. 응집도가 높아지면 재사용성과 가독성이 높아지게 된다.

![Image](https://github.com/user-attachments/assets/90e9e24c-9663-46b7-8194-ed59b948877d)

위의 상황은 서빙을 하는 홀 직원과 계산, 조리, 서빙을 담당하는 셰프로 이루어진 식당이 운영된다.

만일, 해당 음식점에서 서빙의 방법과 조리 방법이 달라졌다면 셰프 클래스를 2가지 이유로 수정해야 한다.

## 2. Open Closed Principle(개방 폐쇄 원칙)

확장에는 열려있고 변경에는 닫혀야 하는 원칙으로, **새로운 요구사항을 구현할 때 기존의 코드를 수정(변경)하지 않고 기능을 추가(확장)할 수 있어야 한다는 원칙**이다. 빠르게 기능을 추가하고 배포하기 위해서 지켜야 할 규칙이다.

이를 가능하게 하려면 클래스나 모듈을 어떻게 설계해야 할까?

바로, 응집도는 높게 결합도는 낮게 프로그램을 설계하면 된다. 응집도는 높게 결합도는 낮게 하려면 어떻게 할 수 있을까? SRP원칙을 지키며 응집도를 높이고, 결합도를 낮추기 위해 인터페이스를 활용하면 될 것이다.

### 사례

템플릿 메소드 패턴, 전략 패턴 등

## 3. Liskov Substitution Principle(리스코프 치환 원칙)

<aside>
💡

S 타입의 객체 o1과 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 프로그램 P 에서 o2를 o1으로 치환해도 P의 행위가 변하지 않는다면, S는 T의 하위타입이다.

</aside>

즉, 하나의 타입을 활용하는 프로그램에서 다른 타입으로 치환해도 프로그램의 행위가 변하지 않는다면, 그 두 타입은 서로 상, 하위 관계를 갖게 된다는 것이다.

상, 하위 관계를 갖게 되면서 타입을 서로 치환할 수 있는 관계가 되는데 이를 해치지 않기 위해서는 부모의 동작을 수정하면 안된다.

이 말을 들으면 클래스 오버라이드를 하면 안되는가? 생각할 수 있다. 오버라이드는 해도 된다. 단, 오버라이드 시 부모의 동작과 다르게 하면 안된다는 제약이 생긴다는 것이다.

## 4. Interface Segregation Principle(인터페이스 분리 원칙)

<aside>
💡

사용하지 않는 것에 의존하지 않아야 한다.

</aside>

인터페이스를 기능 별로 나누더라도 만일 사용하지 않는 함수가 존재한다면, 인터페이스를 분리해야 한다는 것이다.

## 5. Dependency Inversion Principle(의존성 역전 원칙)

<aside>
💡

추상화에 의존해야 하며 구체화에 의존하면 안된다.

</aside>

구현체를 직접 참조하지 않고, 인터페이스를 통해 참조하도록 수정해야 한다.

구현체를 직접 참조하게 되면 참조하는 클래스는 참조되는 구현체 클래스로 향하는 화살표로 보인다.

인터페이스를 참조하도록 수정하면, 해당 인터페이스를 구현하는 구현체는 따로 있을 것이다. 따라서, 참조하는 클래스는 인터페이스를 참조하며, 인터페이스의 구현체는 인터페이스를 구현하는 반대의 화살표를 가리키게 된다.

따라서, 인터페이스(추상화)에 의존해 활용해야 하는 법칙이다.

### 참고

[SOLID (객체 지향 설계)](https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84))

[모든 개발자가 알아야 할 SOLID의 진실 혹은 거짓](https://tech.kakaobank.com/posts/2411-solid-truth-or-myths-for-developers/)