# 테스트 더블

> SW **테스트 자동화에 사용되는 테스트 기법**으로 테스트가 **실제 프로덕션 코드에 의존하지 않도록 종속성을 충족시키는 역할**을 한다.
>

예를 들어, DB에서 데이터를 가져오는 Service계층을 개발했다고 가정해 보자. 이 기능을 테스트하려면 어떻게 해야 할까?

1. 테스트용 데이터를 DB에 넣는다.
2. 해당 데이터를 개발한 Service 메소드를 호출한다.
3. Service메소드에서 DAO 객체에 접근해 데이터를 요청한다.
4. 반환받은 결과값과 예상 값을 비교해 검증한다.

그러나 이 방식은 DAO객체와 Service계층의 **강한 종속성**을 만들어낸다. 테스트를 위해 추가적인 작업이 발생함에 따라 번거로운 테스트 과정이 발생한다.

이런 강한 종속성을 해결해 주는 것이 바로 **테스트 더블**이다.

## 테스트 더블의 종류

![Image](https://github.com/user-attachments/assets/b124207a-caef-4cfb-b654-70f962082db3)

### 1. Dummy

> 가장 기본적인 테스트 더블로, **인스턴스화 된 객체가 필요하지만 기능이 필요하지 않은 경우**에 사용된다.
>

즉, 그냥 인스턴스 그 자체만 테스트 할 메소드에서 매개변수로 활용된다는 것이다. 그냥 타입에 맞는 인스턴스만 채워 넣는다!

예를 들면, 로깅을 활용하는 메소드에서 로깅 기능을 테스트 할 필요는 없다. 하지만, 로깅을 위한 로거를 인자로 받는다면? 테스트를 위해서는 Logger를 메소드의 매개변수로 전달해야한다.

이런 경우 Logger는 테스트를 위해 활용될 필요가 없기 때문에 실제 환경에서 Logger를 억지로 가져오는 것도 이상하다. 따라서, 이런 Logger와 같이 테스트를 위해 필요하지 않는 인스턴스를 만들어 대신 주입하는 방식으로 활용한다.

### 2. Stub

> Dummy 객체가 **실제로 동작하는 것처럼 보이게 만들어 놓은 객체로 특정 입력에 대해 미리 정해진 값을 반환하는 객체**이다.
>

즉, 테스트를 위해 고정된 결과를 제공하는 것이다.

테스트를 할 때 고정된 결과를 제공하는 Stub이 왜 필요할까?

DB에서 값을 조회하는 기능이 있을 때, DB에 데이터를 넣어 테스트를 할 것인가? 이는 단위 테스트의 범위를 벗어난다. DB연동까지 테스트를 하기 때문이다. 따라서, 단위 테스트를 위해서는 DB와 연동을 통해 받은 데이터를 검증하는 것이 아니라 미리 정해놓은 데이터를 받아 검증만 하면 되는 것이다.

### 3. Spy

> 실제 구현을 수행하면서 **호출 기록을 추적하는 객체**이다.
>

테스트를 원하는 실제 객체의 구현을 수행함과 동시에 객체의 호출을 추적하는 객체이다.

따라서, 실제 로직 수행 후 특정 함수의 호출이 발생했는지에 대한 테스트가 가능하다.

사례)

- 이벤트 리스너가 정상적으로 동작하는지 확인
- 데이터 변경 후 특정 메서드가 호출되었는지 검증
- 실제 로직을 수행하면서도 함수 호출 여부를 추적

### 4. Mock 객체

> Stub과 마찬가지로 입력에 대한 기대를 명세하고, **호출된 횟수나 방식까지 검증이 가능**한 객체이다.
>

Stub객체에 호출 횟수까지도 검증할 수 있는 객체이다.

사례)

- API요청이 특정 횟수만큼 호출되었는지 검증
- 알림 전송 서비스가 올바르게 동작하는지 확인
- 이벤트 핸들러가 특정 이벤트에서 호출되는지 테스트

Mock 객체를 활용할 수 있게 해주는 FrameWork는 다양하게 존재한다. 그 중 활용하는 Mock 객체 프레임 워크는 Mockito가 있다.

### 5. Fake 객체

> **단순한 로직**을 지니지만, **실제 동작이 가능한 대체 구현체**이다.
>

즉, 객체의 의존성을 지니는 객체에 대한 단순한 구현체를 말한다. (미니미니 구현체 - 검증하고자 하는 기능에 필요한 기능만 간단히 구현)

예를 들면, DB와 연동되는 코드를 테스트 할 때 테스트 대상 코드는 DB에 강하게 결합되어 있다. Mock이나 Stub을 활용해 기대 명세를 미리 정할 수도 있지만, DB를 대체할 간단한 DB(인메모리 DB)를 만들어 테스트할 수 있다.

## 의문점

### Mock, Stub이나 Fake 객체 모두 결과물을 도출하고 결과물과 기대값을 비교해 검증하는데 굳이 Fake객체를 구현해서 테스트 해야하는가?

답은 필요한 경우도 존재한다 이다. Mock과 Stub의 경우 기대 명세를 미리 정하고 해당 **Mock 혹은 Stub을 실행했을 때 결과값은 정해져있다**.(정적이다.)

반면, Fake객체는 기능을 지니고 있고 호출에 따라 상태가 변화하는 객체의 Fake역할을 한다면 이야기가 달라진다. 예를 들면, DB의 Fake객체를 만들고 DB에 저장되는 데이터가 3개까지만 가능하도록 하는 기능을 테스트 한다고 가정해보자.

이 경우 결과 값이 정해진 Mock객체와 Stub객체의 결과 값으로 테스트가 가능할까? 유효한 테스트 코드가 될 수 없다. 따라서, DB를 위한 Fake객체를 만들고 실제 데이터를 3개까지 저장한 후 해당 Fake 객체를 통해 3개까지 저장 되었는지를 검증하면 유효한 검증이 될 것이다. 즉, 객**체의 상태를 기반으로 검증해야 할 때 필요**하다.

또한, Mock과 Stub이 너무 많아지는 경우 코드가 테스트 코드가 읽히지 않을 수 있기 때문에 이럴 때는 Fake객체를 만들어 Mock과 Stub을 활용하기 위한 코드를 줄여 가독성을 높이는 방법이 존재한다.

### Spring에서 Fake객체를 활용하면 Repository와 같은 Dao객체에 활용할 텐데 이미 Service에 의존성 주입이 이루어지는데 어떻게 테스트 시 Fake객체를 Service에 의존성 주입을 이룰 수 있는가?

Spring에는 `@TestConfiguration` 애너테이션을 통해 Test환경에 대한 Configuration을 진행할 수 있다. 해당 설정 클래스에는 `@Configuration` 과 같이 `@Bean` 애너테이션을 통해 IOC컨테이너에 빈을 생성할 수 있다.

이렇게 생성된 빈을 Test환경에서 Service객체에 주입할 수 있는데 이는, `@Import(TestConfiguration.class)` 애너테이션을 활용해 Test환경 설정 클래스를 가져올 수 있다. 이렇게 가져온 후 Fake 객체를 `@Autowired`로 주입하면, Spring이 자동으로 Service 클래스의 DAO 의존성을 Fake 객체로 대체해준다.

### 참고

[Test double](https://en.wikipedia.org/wiki/Test_double)

[테스트 더블 (Test Double)](https://hudi.blog/test-double/)

[Test Double을 알아보자](https://tecoble.techcourse.co.kr/post/2020-09-19-what-is-test-double/)