# 자바의 동작 원리

## 자바의 동작 원리 개요

자바 언어는 Java Compiler와 JVM을 거쳐 기계어로 변환 후 컴퓨터에 의해 실행될 수 있다.

![Image](https://github.com/user-attachments/assets/e79fcf98-f9ad-4f31-a639-cc030c34105e)

과정)

1. 개발자가 **Java언어로 코드( .java)를 작성**한다.
2. 작성된 코드를 실행하면 **Java Compiler에 의해 바이트 코드(.class)로 변환**된다.
3. 변환된 바이트 코드를 **JVM의 JIT컴파일러, 인터프리터에 의해 기계어로 변환**한다.
4. 기계어를 **컴퓨터가 실행**한다.

### 왜 바이트 코드?

**JVM이 이해할 수 있는 언어**로 작성된 바이트 코드는 **운영체제(OS)나 하드웨어에 종속되지 않는다**. 즉, OS나 하드웨어가 달라진다고 해도 명령어가 달라질 필요가 없다는 것이다.

이것이 가능한 이유는 JVM이 이해할 수 있는 **독자적인 형식**으로 되어 있고, 만약 OS나 하드웨어가 다르다면 JVM에서 OS와 하드웨어의 상황에 맞게 바이트 코드를 기계어로 변환해준다.

결과적으로 바이트 코드와 JVM의 존재에 따라 **플랫폼 독립적으로 동작하는 Java의 특성을 이룰 수 있는 것이다**.

## 자바 실행 구성요소

![Image](https://github.com/user-attachments/assets/71defd36-81f2-4eda-8d7e-ac53ffb752ce)

1. 자바 컴파일러(Java Compiler)
2. 실행 엔진 (Excution Engine)
3. 클래스 로더 (Class Loader)
4. 가비지 컬렉터 (Garbage Collector)
5. 런타임 데이터 영역 (Runtime Data Area)

### 1. 자바 컴파일러(Java Compiler)

Java언어를 위한 컴파일러로, Java언어로 작성된 파일(.java)을 자바 바이트 코드를 담고 있는 자바 클래스 파일(.class)로 컴파일한다.

자바 컴파일러는 JDK나 JRE의 `bin` 폴더에 `javac.exe` 파일이 존재한다. 해당 실행 파일이 java compiler의 실행 파일이다.

![Image](https://github.com/user-attachments/assets/e6dad4d1-824a-4084-808c-c498c8d8c553)

### 2. 실행 엔진(Excution Engine)

실행 엔진은 JVM메모리에 올라온 바이트 코드들을 명령어 단위로 가져와 실행한다. 엔진의 동작 방식은 인터프리터와 JIT(Just In Time)컴파일러 2가지 요소가 존재한다.

1. **JIT컴파일 방식(정적 컴파일 방식)**

컴파일의 개념 그대로 바이트 코드를 기계어로 번역한다. 하지만, 일반 컴파일러 언어와 다른 점은 코드가 실행되는 과정(Just In Time)에 컴파일 한다.

컴파일의 대상은 **자주 실행되는 코드를 컴파일 한다**. 컴파일 한 후 해당 실행 코드는 캐시에 저장하게 된다. 이후, 다시 해당 코드가 실행되면 인터프리터 방식으로 실행되는 것이 아닌 캐시에 저장된 실행 코드를 기반으로 실행된다.

**자주 실행되는 코드로 판단되는 조건**

- 메소드 호출 횟수
- 루프문을 돈 횟수

두 횟수의 합계를 확인 후 컴파일 여부를 판단한다.

1. **인터프리터 방식(원래는 이것만 사용했음)**

바이트 코드를 한 줄씩 읽어서 즉시 실행하는 방식으로 실행 속도는 빠르지 않지만, 시작을 빠르게 할 수 있다.(전체 컴파일에 비하면 빠르다는 이야기)

초기 실행 시 사용되며, JIT컴파일러가 활성화 되기 전까지 실행되는 코드이다.

### 3. 클래스 로더(Class Loader)

> 자바 클래스(.class)를 자바 가상머신(JVM)으로 동적 로드하는 자바 런타임 환경(JRE)의 일부이다.
>

정확히는 자바 클래스(.class)를 자바 가상 머신의 메모리 영역 중 메소드 영역에 클래스 단위로 로드한다.

클래스 로더는 어떤 종류의 클래스를 로드하느냐에 따라 종류가 나뉜다.

**클래스 로더의 종류**

1. **부트스트랩 클래스 로더**
   `<JAVA_HOME>/jre/lib` 디렉터리에 위치한 핵심 자바 라이브러리들을 불러들인다. `java.lang.*`
2. **확장 클래스 로더**
   확장 디렉터리(`<JAVA_HOME>/jre/lib/ext` 또는 `java.ext.dirs` 시스템 속성에 지정된 기타 디렉터리)에 코드를 로드한다
3. **애플리케이션 클래스 로더(시스템 클래스 로더)**
   애플리케이션 클래스 경로(`CLASSPATH`)에 있는 클래스를 로드한다.

**클래스 로더의 동작 방식**

1. **클래스 요청**
   프로그램에서 클래스가 사용될 때 JVM은 클래스가 메소드 영역에 로드 여부를 확인 후 로드되지 않았다면 클래스 로더에게 로드 요청을 보낸다.
   ex) `new MyClass()` , `Class.forName("MyClass")` 등 클래스 로딩이 트리거 됨
2. **클래스 로더 탐색**
   클래스 로드 요청을 받은 클래스 로더는 **클래스 경로에서 해당 클래스를 찾는다**.(클래스 로더는 **자신만의 검색 경로에 따라 클래스를 탐색**한다.)
3. **클래스 검색**
   클래스 로더는 **부트스트랩 클래스 로더**, **확장 클래스 로더**, **애플리케이션 클래스 로더** 순으로 로드를 시도한다. .
4. **클래스 로딩**
   클래스 로더는 클래스 바이트코드를 읽고, 이를 메모리(메소드 영역)에 적재한다. 이때, 클래스의 정적 변수, 메소드, 상수 풀 등이 메모리에 적재된다.
5. **클래스 초기화**
   클래스를 메모리에 로드한 후 **클래스의 정적 초기화 블록이나 정적 변수 등이 초기화 된다**.
6. **클래스 사용**
   클래스가 로드되고 초기화 된 후 프로그램 내에서 **정상적으로 사용**될 수 있다.(객체 생성, 메소드 호출)

> **정적 블록(Static Block)이란?**
클래스 내 **단 한번만 실행되어야 하는 코드들을 모을 수 있다**.
즉, 클래스가 메모리에 처음으로 로딩될 때 한 번만 실행될 코드를 담는 블록으로 정적 변수 초기화와 같은 **클래스 공통적으로 실행되어야 하는 코드가 들어간다**.

중요!!)
클래스 로드 시 정적 **변수 초기화가 정적 블록 초기화 보다 더 우선적으로 실행**된다.
>

```java
static {
	int n = 3;
	int m = 4;
}
static int n = 1;
```

### 4. 가비지 컬렉터(Garbage Collector)

Java프로그램이 동작하면서 불 필요한 메모리(사용하지 않는 메모리) 할당을 해제해준다.

C언어의 경우 `malloc` 을 통해 동적으로 할당된 힙 메모리를 사용하지 않은 시점이 되면 `free` 명령을 통해 해제해주는데 Java의 경우 이런 명령을 실행할 필요가 없다.

GC가 대신 해당 작업을 해주기 때문이다.

가비지 컬렉터는 주기적으로 메모리 활용 여부를 판단하고 메모리를 해제한다.

### 5. 런타임 데이터 영역(Run Time Data Area)

JVM의 메모리 영역으로 Java 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다. 운영체제로 치면, 프로세스의 메모리 구조를 지니는 것과 동일하다.

![Image](https://github.com/user-attachments/assets/7cdd1d8c-a372-4a6f-8cc8-971deeafd4b1)

**영역의 종류**

1. **Method영역(Static, Class영역)**

   클래스 로더에 의해 로드된 클래스 정보들을 해당 영역에 저장된다.
   JVM이 읽어들인 **클래스, 인터페이스, 런타임 상수 풀, 필드와 메서드 정보, 생성자, Static 변수, 메서드의 바이트 코드** 등 클래스 수준의 구조를 저장한다.

2. **Heap영역**

   객체와 배열이 할당되는 영역으로 런타임 시 크키가 결정된다.
   해당 영역은 GC(Garbage Collector)가 동작하는 영역이다.

3. **Stack영역**

   메서드 호출 시 **지역 변수, 매개변수, 반환 주소, 함수 호출 내역 등**이 저장되는 영역이다.

4. **PC 레지스터**

   각 스레드마다 **현재 수행 중인 JVM 명령의 주소가 저장**되는 영역이다.
   실행 중인 바이트코드 명령어를 추적한다.

5. **네이티브 메서드 스택**

   **자바 외의 언어로 작성된 네이티브 코드를 위한 스택**으로 Java Native Interface를 통해 호출하는 C/C++ 코드를 수행하기 위한 스택이다.


## 결론(자바의 동작 정리)

1. **자바 코드 실행**: 사용자가 작성한 자바 코드가 실행된다.
2. **컴파일**: Java Compiler(`javac`)에 의해 자바 코드가 **바이트 코드**(.class 파일)로 컴파일된다.
3. **클래스 로드**: JVM은 받은 바이트 코드를 **클래스 로더**에게 요청한다.
    - **클래스 로더**는 클래스가 위치한 경로를 탐색한 뒤, 요청한 클래스가 있으면 **JVM의 런타임 데이터 영역(Method 영역)**에 클래스를 로드한다.
4. **실행 엔진**: JVM의 실행 엔진(Interpreter)이 **바이트 코드**를 한 줄씩 읽어 해석(인터프리트)하며 실행한다.
    - 실행 도중, JIT(Just-In-Time) 컴파일러는 자주 실행되는 코드(Hot Code)를 네이티브 코드로 변환한 뒤 **캐싱**하여 성능을 최적화 한다.
5. **런타임 데이터 영역의 변화**: 실행 중에는 JVM의 **런타임 데이터 영역**이 동적으로 사용된다.
    - **Stack**: 메서드 호출과 지역 변수 관리.
    - **PC 레지스터**: 현재 실행 중인 명령어 추적.
    - **Heap**: 객체와 배열 저장 및 가비지 컬렉션 수행.

### 참고

https://velog.io/@ddangle/Java-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%8D%94%EB%9E%80

https://mangkyu.tistory.com/118

https://inpa.tistory.com/entry/JAVA-%E2%98%95-JVM-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD-%EC%8B%AC%ED%99%94%ED%8E%B8#%EB%9F%B0%ED%83%80%EC%9E%84_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%98%81%EC%97%AD_runtime_data_area