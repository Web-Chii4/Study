## 가상 메모리

> 컴퓨터의 **물리적 메모리 (RAM)보다 더 큰 메모리를 사용할 수 있도록 해주는 기법**
>

즉, 프로그램이 실행되기 위해서는 프로세스가 메모리에 모두 올라가야 하는데, 메모리의 용량이 부족하거나, 프로세스의 크기가 메모리 보다 큰 경우에도 프로그램이 실행될 수 있도록 해주는 기법이다.

## 가상 메모리 동작 방식

### 사전 지식

**페이지 테이블**

- 가상 주소와 물리 주소를 매핑한 테이블

**MMU(Memory Management Unit)**

- CPU와 메모리 사이의 주소 변환을 담당하는 HW장치로, 페이지 테이블을 활용해 주소 변환을 이룬다.

**스와핑(Swapping)**

- 디스크 영역과 메모리 영역의 데이터를 교환하는 동작을 말한다.
- 물리 메모리에서 디스크로 이동은 **스왑 아웃**
- 디스크에서 물리 메모리로 이동은 **스왑 인**

**스왑 영역(Swap area)**

- 물리 메모리를 확장하기 위한 공간 만큼 사용하는 디스크 영역
- 해당 영역은 운영체제 설치 시 시스템 관리자가 위치와 크기를 결정한다.
- 운영체제마다 스왑 영역 구성 방법은 다르다.

![Image](https://github.com/user-attachments/assets/16b0182e-1047-4516-849a-f4d1cc558b70)

결과적으로, 디스크에 스왑 영역을 만들고, 해당 영역 만큼의 메모리 공간이 생겨나는 효과를 볼 수 잇는 것이다.

## 가상 메모리 구현 기법

### 1. 요구 페이징 기법(demand paging)

> 메모리 관리 기법 중 하나인 페이징 기법을 활용해 프로세스의 **일부 페이지들만 메모리에 적재**하고 나머지는 디스크에 저장해 페이지 단위로 메모리 할당 및 페이지를 적재하는 방식
>
- 해당 방식은 Page단위로 Swapping이 이루어진다는 것이 중요하다.
- 오늘날 대다수의 운영체제는 요구 페이징 기법을 사용한다.

### 2. 요구 세그먼테이션 기법(demand segmentation)

> 메모리 관리 기법 중 하나인 세그먼테이션 기법을 활용해 프로세스를 **논리적 단위(세그먼테이션)로 스와핑해 메모리를 관리하는 방식**이다.
>
- 잘 사용되지 않는 기법이다.

## 페이지 폴트

CPU가 메모리에 접근할 때 가상 주소를 MMU에게 전달하고, MMU는 페이지 테이블을 참고해 물리 주소를 알아낸다. 이후, 알아낸 물리주소에 접근해 데이터를 가져오게 된다.

하지만, **페이지가 물리 메모리에 없는 경우를 페이지 폴트라고 한다.**

반면, 페이지가 **메모리에 있는 경우는 페이지 히트라고 한다.**

- 페이지 폴트가 발생하면, 페이지 폴트 핸들러에 의해 물리 메모리에 빈 프레임을 만든다.
- 만일, 여기에 빈 프레임이 없다면, 희생 페이지를 지정해 해당 페이지를 스왑 아웃 시키고, 적재할 페이지를 스왑 인 시켜야 한다.

페이지 폴트 발생 시 문제점은 스왑 영역에 존재하는 페이지를 메모리에 스왑 인 할 때 속도가 느려지는 것이 문제이다.

따라서, 운영체제에는 이를 해결하기 위해 희생 프레임을 어떻게 선택할 것인가에 대한 다양한 페이지 교체 알고리즘들이 존재하며, 이로써 스와핑의 빈도를 줄인다.

## 페이지 교체 알고리즘

> **페이지 교체 알고리즘은 페이지 폴트가 발생한 경우 희생 페이지를 선택해야하는 상황에 참조 지역성을 활용해 스와핑하는 알고리즘**을 말한다.
>

**사전 지식)**

**시간 지역성** : 프로그램에서 참조되는 주소가 **가까운 미래에 다시 참조될 가능성이 큰 특성**

**공간 지역성** : 참조되는 주소의 **인접한 메모리 주소들이 참조되는 특성**

**지역 교체** : **페이지 적재를 요청한 프로세스에서 희생 프레임을 선택**하는 방식이다.

**전역 교체** : 프로세스와 상관 없이 **모든 프로세스에서 희생 프레임을 선택하는 방식**이다.

### 1. 최적 교체 알고리즘(OTP)

> **가까운 미래에 사용될 가능성이 낮은 페이지를 희생 페이지로 선택**하는 기법이다.
>
- 해당 알고리즘은 시간 지역성이 낮은 페이지를 희생 페이지로 선택한다. 따라서, 해당 기법은 페이지 폴트가 가장 작은 이상적인 방법이다.
- 하지만, 페이**지들이 언제 참조될 것인지 모두 알아야 구현 가능하기 때문에 실현이 불가능** 하기도 하다.

### 2. FIFO(First In First Out) 알고리즘

> **메모리에 적재된 페이지 중 가장 먼저 적재된 페이지를 희생 페이지로 선택하는 기법**이다.
>
- 구현은 쉬우나, 작업 집합을 고려하지 않기 때문에 성능이 낮다.

**작업집합**

- 일정 시간 동안 프로세스가 처리한 페이지들의 집합

### 3. LRU (Least Recently Used) 알고리즘

> 프레임에 적재된 페이지들 중 **가장 오래전에 참조된 페이지를 희생 페이지로 선택**한다.
>
- 해당 기법은 참조의 지역성 중 **시간 지역성을 활용한 방법**이다.
- 뛰어난 알고리즘으로 유닉스나 리눅스 등 많은 운영체제에서 사용된다.
- 희생 페이지를 선택할 때 가장 오래됨의 판단의 기준으로 참조 비트를 활용한다

실제 시간 정보를 저장하게 되면, 모든 페이지들을 순회하고, 가장 오래 전에 사용된 페이지를 선택해야 한다. 이를 개선하기 위해 **카운터**라는 값을 페이지 테이블에 저장한다.

카운터는 페이지가 참조될 때마다 올라가는 value로 값이 클 수록 가장 최근에 참조됐음을 뜻한다. 따라서, 희생 페이지를 선택할 때 value가 가장 작은 페이지(즉, 가장 오래 전에 참조된 페이지)를 희생 페이지로 지정한다.

### 4. Clock 알고리즘

![Image](https://github.com/user-attachments/assets/1dfa88fa-6d0d-4c66-a430-820765cb769e)

> LRU의 변형 알고리즘이다.
>

**동작 과정)**

1. 페이지 교체 요청 발생
2. 원형 큐를 따라 포인터가 시계방향으로 회전한다.
    1. 참조 비트가 1인 프레임을 만나면 참조 비트를 0으로 변환하고 다음으로 넘어간다.
    2. 참조 비트가 0인 프레임을 만나면 해당 프레임을 희생 프레임으로 선택한다.

**참조 비트**

페이지 테이블에 존재하는 값으로, CPU에 의해 호출될 때 카운터 값이 0인 경우 참조 비트는 1로 변환된다. 하지만, 1인 경우 다시 0으로 바꾼다.

위의 동작 과정으로 인해 LRU알고리즘의 모든 참조 비트를 주기적으로 0으로 초기화 하는 과정을 없애 효율성을 높일 수 있게 된다.

따라서, **해당 기법이 운영체제에서 가장 많이 쓰인다.**

### 5. MFU(Most Frequently Used)

> 가**장 많이 참조된 페이지를 희생 페이지로 선택**한다.
>

### 6. LFU(Least Frequently Used)

> **가장 적게 참조된 페이지를 희생 페이지로 선택**한다.
>

### 참고

[[운영체제] 가상 메모리](https://velog.io/@redgem92/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC)

[[운영체제] 가상메모리](https://velog.io/@kkyu0718/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC)