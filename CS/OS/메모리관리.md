# 메모리 관리

> 프로그램이 실행되면 디스크에서 메모리로 프로그램이 적재되고 실행된다. 이에 OS는 메모리가 효율적으로 사용되도록 관리한다.
>

## Goal

- 메모리 관리 알고리즘을 알 수 있다.
- 메모리 단편화의 종류를 알 수 있다.
- 메모리 단편화 해결 기법을 알 수 있다.

## 메모리 관리 방식(연속적 할당 기법)

메모리에는 기본적으로 프로세스가 적재된다. 프로세스가 적재될 때 얼만큼의 크기의 공간을 할당할 것인지에 따라 **고정 분할 방식**과 **가변 분할 방식**으로 나뉜다.

### 1. 고정 분할 방식

> 메모리를 **다중 크기(여러 크기의 파티션을 혼합)로 나누어 하나의 파티션 당 하나의 프로세스를 할당**한다.
>

해당 방식은 프로세스가 사용하는 용량보다 더 큰 용량의 파티션을 할당 받게 되면, **내부 단편화**가 발생한다.

### 2. 가변 분할 방식

> **프로세스가 필요한 만큼 동적으로 메모리를 할당**하는 방식이다.
>

프로세스가 종료되면서 빈 공간들이 생겨나게 되면서 새로운 프로세스가 들어갈 공간이 부족해지는 **외부 단편화**가 발생한다.

## 단편화

> 메모리에 **사용되지 않는 공간이 존재하지만, 빈 공간이 효율적으로 활용되지 못해 새로운 프로세스를 적재하기 어려운 현상**을 말한다.
>

단편화에는 **외부 단편화**, **내부 단편화** 2가지 종류가 있다.

### 외부 단편화

> 사용할 수 있는 총 메모리 공간은 충분하지만, **남은 공간들이 작은 조각으로 흩어져 있어 프로세스를 적재할 수 없는 현상**이다.
>

과정)

1. 프로세스 A는 10MB, 프로세스 B는 5MB, 프로세스 C는 20MB, 프로세스 D는 10MB
2. 프로세스 B 와 프로세스 D가 종료됨
3. 프로세스 E(15MB가 필요)가 실행됨
4. 하지만, 남은 공간은 총 15MB이지만, 흩어져 있어 프로세스를 적재할 수 없게됨(외부 단편화)

### 내부 단편화

> 프로세스가 **실제 사용하는 공간보다 더 큰 공간을 할당받아 발생하는 사용되지 않는 영역**
>

과정)

1. 메모리는 고정 분할 방식에 의해 6MB공간으로 나뉘게 됨
2. 프로세스 A는 실행에 4MB만 필요하며, 파티션 하나를 할당받아 적재됨
3. 파티션 내에는 사용하지 않는 2MB가 존재하게 됨(내부 단편화)

## 메모리 관리 알고리즘

**고정 분할 방식**은 이미 메모리가 정해진 크기로 나뉘어 있기 때문에 프로세스를 어느 공간에 할당해야 하는지 고려할 필요가 없다. 따라서, 해당 관리 알고리즘들은 **가변 분할 방식**에서 활용된다.

### 1. First - Fit 방식

![Image](https://github.com/user-attachments/assets/71fa361d-7328-464e-b417-9832dfeaa555)

> 메모리를 순회하며 **적절한 크기의 메모리 공간을 찾으면 해당 공간에 프로그램을 적재하는 방식**
>
- 외부 단편화 발생 가능성이 증가한다.
- 메모리 할당 속도가 빠르다.

### 2. Best - Fit 방식

![Image](https://github.com/user-attachments/assets/3283d36b-baf8-4cd3-a63c-e8fecd147de4)

> 메모리를 전체 순회한 이후, 프로그램이 적재될 수 있는 공간들 중 가장 작은 공간을 선택해 적재하는 방식이다.
>
- 외부 단편화가 발생할 수 있다.

### 3. Worst - Fit 방식

![Image](https://github.com/user-attachments/assets/14e37b21-9b53-47c0-a4aa-4ac505781a0a)

> 메모리를 전체 순회한 이후, 프로그램이 적재될 수 있는 공간들 중 가장 큰 공간을 선택해 적재하는 방식이다.
>
- 큰 빈 공간이 빠르게 조각나면서 외부 단편화가 심해질 수 있다.
- 시간이 지날 수록 점점 조각화된다.

## 메모리 단편화를 해결하기 위한 개선된 메모리 관리 기법(불 연속적 할당 기법)

메모리 단편화의 해결 기법이지만, 단편화의 문제를 100% 해결하지는 못한다.

### 1. 페이징 기법

> 고정된 크기(Page)로 메모리를 분할해 프로세스를 할당하는 기법
>
- 해당 기법은 페이지 테이블을 활용해 페이지(논리적 공간)를 프레임(물리적 공간)와 매핑한 데이터를 저장한다.
- 외부 단편화를 해결할 수 있지만, **내부 단편화가 발생**한다.

![Image](https://github.com/user-attachments/assets/6fd5596a-44ad-4b7b-8e4d-66d723a09a99)

![Image](https://github.com/user-attachments/assets/255bf11f-59e3-44c6-89a9-8dc0dbc171b9)

### 2. 세그먼테이션 기법

> 프로세스가 **할당 받은 메모리 공간을 논리적 의미의 단위(세그먼트)로 나누어 연속되지 않는 물리 메모리 공간에 할당될 수 있도록 하는 관리 기법**
>

![Image](https://github.com/user-attachments/assets/59b2503d-db4a-49ba-b603-c91446f86f93)

- 주로, 논리적 의미의 단위의 기준점이 되는 것은 Stack, Heap, Code, Data영역을 단위로 Segment를 정의하는 경우가 많다.
- 페이징 기법과 마찬가지로 세그먼트 테이블을 가지고 있다.

## 정리

| 기법 | 메모리 할당 방식 | 연속된 공간 할당 여부 | 사용되는 테이블 |
| --- | --- | --- | --- |
| **세그먼테이션** | 프로세스를 다양한 크기의 세그먼트로 나눔 | **비연속적** | **세그먼트 테이블** |
| **페이징** | 프로세스를 고정 크기의 페이지로 나눔 | **비연속적** | **페이지 테이블** |
| **고정 분할** | 고정 크기의 파티션으로 나눔 | **연속적** | 해당 없음 |
| **가변 분할** | 프로세스 크기에 맞게 동적으로 할당 | **연속적** | 해당 없음 |

### 참고

[페이징(Paging)과 세그먼테이션(Segmentation)](https://velog.io/@gang_shik/%ED%8E%98%EC%9D%B4%EC%A7%95Paging%EA%B3%BC-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98Segmentation)

[[운영체제] 메모리 관리 기법 - 페이징 & 세그멘테이션](https://hyuuny.tistory.com/155)