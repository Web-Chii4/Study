# 프로세스 관리

실행되는 프로그램인 프로세스를 운영체제는 어떻게 관리할까? 우선 어떠한 것을 관리하기 위해서는 **관리 대상의 정보**가 존재해야 한다.

OS에서 관리 대상의 정보를 보관하기 위해 **PCB(Process Control Block)**을 생성하고 이를 통해 관리한다.

## PCB(Process Control Block)

> 특정 **프로세스에 관한 정보(프로세스 식별자, 프로세스 상태 등)를 저장하는 OS의 자료 구조**이다. - 커널에 존재하는 작은 데이터 구조
>

프로세스는 컴퓨터의 한정된 자원(CPU, I/O장치 등)을 활용하고, 프로세스는 CPU코어 수보다 훨씬 많다. 이에 프로세스들이 컴퓨터의 한정된 자원들을 공평하게 활용할 수 있도록 프로세스에게 상태를 부여한다. 이후 프로세스 상태 변화에 따라 CPU를 다른 프로세스에게 할당하기 위한 작업인 Context Switching을 이루기 위해 PCB에 데이터를 저장한다.

Context Switching을 이루기 위해서 PCB에 저장된 데이터를 활용한다.

**PCB에 저장되는 데이터들은 다음과 같다.**

- 프로세스 식별자(PID)
- 프로세스 상태
- 프로그램 카운터(PC)
- CPU 레지스터(실행중이던 프로세스의 CPU레지스터 값)
- CPU 스케줄링 정보
- 메모리 관리 정보
- I/O 상태 정보
- 계정 및 사용자 정보

위에서 볼 수 있듯이, OS가 PCB에 저장하는 데이터들은 프로세스의 식별자와 같이 고유한 데이터들도 존재하지만, 프로세스가 대기 상태에 있다가 실행 상태로 돌입했을 때 이전에 수행하던 작업을 무탈히 수행하기 위해 PCB의 데이터들을 꺼내 사용하게 된다.

대기 상태에 들어가기 전 현재 프로세스가 작업하는 상태를 PCB에 저장하고 대기상태에 들어가고, 다른 프로세스는 자신의 PCB를 기반으로 CPU를 점유하게 된다. 이에 따라 Context Switching(문맥 교환)이라는 언어의 의미는

**서로 다른 프로세스 간 CPU점유를 변경하기 위해 PCB(프로세스의 상태)를 기반으로 CPU점유를 변경한다는 의미로 보인다.**

## 프로세스의 상태

OS는 프로세스를 상태로서 관리한다. 따라서, 상태에 따라 프로세스가 하는 동작은 달라진다.

![Image](https://github.com/user-attachments/assets/a9b057ef-4d6b-4bef-95fb-967a22c8444b)

1. **생성(Create)**

   프로세스가 생성된 상태로 운영체제가 프로세스를 관리하기 위해 필요한 것들을 준비하는 상태이다.

    - PCB(Process Control Block) 생성
    - Process가 점유할 메모리(RAM) 공간 할당
2. **준비(Ready)**

   프로세스가 CPU를 할당받아 작업에 들어가기 전 준비 큐(Ready Queue)에서 대기하는 상태이다.

    - CPU를 사용하기 위한 프로세스들은 Ready Queue(준비 큐)에 프로세스 적재되어 프로세스 스케줄러에 의해 CPU를 할당받기 전까지 대기한다.
3. **실행(Running)**

   프로세스가 CPU를 점유하고 실행되는 상태이다.

    - 프로세스의 CPU작업이 실행된다.
    - I/O작업, 프로세스 스케줄러에 의해 중단되지 않는다면 계속 실행된다.
4. **대기(Waiting / Pending)**

   프로세스가 I/O작업을 필요로 하는 경우 I/O작업이 끝날 때까지 대기상태에 돌입한다.

    - I/O작업이 처리될 때까지 대기한다.
    - I/O작업이 끝나면 OS는 System Call을 전달해 대기중인 프로세스에게 신호를 보낸다.
    - 해당 신호를 받은 프로세스는 Ready Queue로 다시 이동해 준비 상태에 돌입한다.
5. **종료(Terminated)**

   프로세스의 동작이 끝난 후의 상태

    - 프로세스가 차지하던 메모리는 OS에 의해 반환되고, 다른 프로세스가 사용할 수 있게 된다.
    - 종료된 상태의 프로세스의 PCB는 즉시 삭제되지 않고, 일정 기간 유지된다. 이후, 부모 프로세스가 자식 프로세스의 종료를 기다리는  `wait()` 를 호출하면 삭제된다.

## 컨텍스트 스위칭(Context Switching)

> 문맥 교환으로, PCB는 프로세스를 제어하기 위한 상태 정보들을 담고 있다. 이를 프로세스의 문맥으로 볼 수 있는데 CPU점유 프로세스를 변경하기 위해 PCB를 기반으로 점유 프로세스를 변경하는 것을 말한다.
>

![Image](https://github.com/user-attachments/assets/6fbe92a0-95b6-42fa-a793-3e603fcabd79)

프로세스 1에서 프로세스 2로 컨텍스트 스위칭 하는 과정을 간단하게 설명해보면

1. 프로세스 1에 대한 정보가 담긴 CPU에서 SP, PC 등 프로세스 실행 정보를 PCB에 담는다.
2. 새로 CPU를 점유할 프로세스 2의 PCB로 부터 프로세스 실행 정보(PC, SP)를 받아 CPU에 저장한다.

### 커널 모드와 사용자 모드

**커널 모드**

> 모든 자원(드라이버, 메모리, CPU 등)에 접근, 명령할 수 있는 상태
>

**사용자 모드**

> 컴퓨터 자원을 보호하기 위해 사용자가 한정된 기능만 사용할 수 있도록 한 상태
>

컨텍스트 스위칭은 새로운 프로세스를 실행하기 위해 **현재 프로세스의 실행 정보를 저장하고, 새로운 프로세스의 정보를 불러오는 과정**이다. 이 과정에서 CPU의 레지스터 값을 변경해야 하므로 **커널 모드에서 실행**되어야 한다. 하지만 사용자 프로그램도 실행해야 하기 때문에 항상 커널 모드에만 머무를 수는 없다.

**과정)**

1. 타이머 인터럽트, 시스템 콜, I/O 요청 등으로 인해 프로세스 실행이 중단됨.
2. CPU가 커널 모드로 전환됨
3. 현재 실행 중인 프로세스의 정보를 PCB에 저장함.
4. 새롭게 실행 할 프로세스의 PCB정보를 CPU에 적재함.
5. CPU가 사용자 모드로 전환됨.
6. 새로운 프로세스를 실행함.

## CPU 스케줄링(Process Scheduling)

> **CPU 스케줄링**은 운영체제(OS)가 **스케줄러**를 통해 **CPU 자원을 어떤 스레드에게 할당할지 결정하는 과정**이다.
>

CPU 스케줄링을 이루기 위한 방법의 종류는 다양하며, CPU를 사용 할 스레드는 스케줄러에 의해 결정된다. 또한, **스케줄러**에 의해 결정된 프로세스는 `Dispatcher`에 의해 CPU를 직접 할당 받는다.

**스케줄링을 통해 이루고자 하는 목표는 다음과 같다.**

- CPU 활용률 향상
- 컴퓨터 시스템 처리율 향상

**활용률**: 컴퓨터의 전체 가동 시간에 대한 CPU 사용 시간의 비율

**처리율**: 단위 시간당 처리하는 스레드의 갯수

여기서 중요한 점은, 스케줄링이 무조건 CPU의 활용률과 처리율을 높여주는 것 만은 아니다. 프로세스 스케줄링 기법을 어떻게 적절히 활용하느냐에 따라 **기아 프로세스**의 발생이 많아질 수도 적어질 수도 있다**.**

**기아 프로세스**: CPU 스케줄러에 의해 우선순위에 지속적으로 밀려 CPU를 오랜 시간 할당받지 못하고 준비 큐에 존재하는 프로세스

### 선점형 스케줄링

> 현재 실행 중인 스레드를 강제로 중단시킨 후 Ready Queue에 이동시킨 후 우선순위가 높은 프로세스가 CPU를 점유하는 방식
>

**RR(Round Robin Scheduling) 스케줄링**

- **모든 스레드에게 일정 시간 동안만 CPU를 할당하는 방식**으로 일정 시간이 끝나면 다른 스레드가 CPU를 점유할 수 있도록 하는 스케줄링 기법이다.
- 공평한 CPU점유를 제공하지만, **잦은 스케줄링으로 인해 스케줄링과 컨텍스트 스위칭으로 인한 오버헤드가 높다**.

**SRTF(Shortest Remaining Time First) 스케줄링**

- 남은 실행 시간이 가장 짧은 스레드를 우선 스케줄링한다.
- 선점형 스케줄링 방식이기 때문에 CPU작업 중인 스레드의 시간이 새롭게 Ready Queue에 들어온 스레드의 실행 시간이 더 짧다면, CPU를 할당 받은 스레드는 Ready Queue에 들어가고 새롭게 온 스레드가 CPU를 점유하게 된다.

**MLFQ(Multi - Level Feedback Queue)**

- n개의 우선순위(Level)로 구분된 큐를 두고, 큐마다 별도의 스케줄링 정책을 사용할 수 있다.(RR이 가장 무난함)
- 스레드가 처음 들어올 때 가장 높은 우선순위의 큐에 들어가고, 우선순위가 높은 큐의 스레드를 우선적으로 스케줄링 한다.
- 낮은 레벨의 큐일수록 RR의 타임 슬라이스는 더 길게 설정되고, 실행 중인 CPU의 작업 시간이 기준 타임 슬라이스 보다 길어지면, 우선순위가 낮은 큐로 스레드는 넘어간다.
- 즉, 이런 방식으로 동작하다보면, RR으로 처리되는 MLFQ의 경우 CPU작업 시간이 긴 스레드는 우선순위가 밀려나고, **결과적으로 CPU작업 시간이 짧은 스레드가 우선적으로 처리되게 된다**.

### 비선점형 스케줄링

> 스레드가 CPU를 할당 받은 경우 해당 프로세스가 I/O 작업, 자발적으로 양보, 스레드 종료 등을 통해 CPU점유를 포기하지 않으면 다른 프로세스는 CPU를 사용할 수 없는 방식이다.
>

**FCFS(First Come First Served) 스케줄링**

- 준비 큐(Ready Queue)에 먼저 도착한 스레드를 먼저 스케줄링(CPU를 할당)한다.

**SJF(Shortest Job First) 스케줄링**

- Ready Queue에서 예상 실행 시간이 가장 짧은 스레드를 우선 선택해 CPU를 할당한다.
- 스레드 별 예상 실행 시간을 예측하기 어렵다는 단점이 있다.

**HRN(Highest Response Ratio Next) 스케줄링**

- SJF기법의 보완책으로, 실행 시간이 긴 프로세스가 늦어지는 현상을 방지하기 위해 등장함
- **`시스템 응답 시간 = (서비스 실행 시간 + 대기 시간) / 서비스 실행 시간`**
- 시스템 응답 시간이 높아질 수록 우선순위가 높아진다.

### 참고

[문맥 교환](https://ko.wikipedia.org/wiki/%EB%AC%B8%EB%A7%A5_%EA%B5%90%ED%99%98)