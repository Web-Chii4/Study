# 프로세스와 스레드

## Goal

- 프로세스와 스레드의 개념을 알 수 있다.

## 프로그램과 프로세스

### 1. 프로그램(Program)

**사전적 정의**

> **하드 디스크, SSD 등의 저장장치에 저장되어 있는 실행 코드를 말한다.**
>

프로그램은 **다양한 언어**(우리가 흔히 아는 C, JAVA, JavaScript, Python 등의 고급 언어)로 작성된 코드를 실행 가능한 형태로 변환하여 저장 장치에 저장한 것이다.

- **컴파일러 언어(C언어)**의 경우, 실행 파일로 컴파일하고 저장 장치에 저장한 뒤 실행하지만, **Python이나 JavaScript와 같은 인터프리터 언어**는 실행 파일을 별도로 생성 및 저장하지 않고 런타임 과정에서 기계어로 변환되며 실행된다.

![Image](https://github.com/user-attachments/assets/704cf408-5e50-4d79-946d-bd8eb3e5836a)

이처럼 인터프리터 언어와 같은 실행 방식이 등장하면서, 프로그램의 정의는 기존과 달라져야 한다고 생각한다.

기존에는 프로그램을 단순히 **저장 장치에 저장된 실행 파일**로 정의했지만, 이는 현대의 다양한 언어와 실행 방식을 충분히 반영하지 못한다. 예를 들어, 인터프리터 언어는 실행 파일로 저장되지 않아도 런타임 환경에서 바로 실행이 가능하기 때문이다.

**프로그램 재정의**

> **컴퓨터가 이해할 수 있는 언어로 작성된 명령어들의 집합**
>

이 정의는 프로그램의 본질을 가장 잘 설명한다. 프로그램은 저장 여부와 무관하게 컴퓨터가 실행 가능한 형태로 존재하는 명령어들의 집합이라는 점에서, 기존의 한정된 정의를 넘어 더 포괄적으로 재정의될 필요가 있다.

### 2. 프로세스(Process)

> **컴퓨터에서 연속적으로 실행되고 있는 프로그램이다.**
>

**사용자가 프로그램을 실행하**면, **운영체제가 프로그램의 실행 파일을 읽어 메모리(RAM)에 적재하고 실행 준비를 완료**한다. 이렇게 적재 된 것을 프로세스라고 부른다.

즉, 운영체제가 실행된 프로그램을 실행 및 관리하기 위한 하나의 단위라고 생각하면 될 것 같다.

### 프로세스의 특징

- **독립적인 실행 단위를 가진다.**
    - 각 프로세스는 고유한 메모리 공간을 가지고, 다른 프로세스와 분리된 상태로 실행된다.
- **고유한 메모리 공간을 가지고, 크게 4가지 영역으로 나눌 수 있다.**
    - 코드, 데이터, 힙, 스택 영역이 존재한다.
- **프로세스의 상태가 존재한다.**
    - 생성, 준비, 대기, 실행, 종료 상태가 존재한다.
- **프로세스 간 통신(IPC: Inter Process Communication)**
    - 프로세스는 다른 프로세스와 직접 메모리를 공유하지 않기 때문에 프로세스 간 통신(IPC)을 통해 데이터를 주고 받아야 한다.
- **프로세스는 실행에 필요한 자원을 소유한다.**
    - CPU시간, 메모리, 파일 및 입출력 디스크립터의 자원을 소유할 수 있다.
- **PID(Process ID)라는 고유 식별 번호를 가진다.**
    - 운영체제는 각 프로세스를 고유하게 식별할 수 있도록 PID를 부여한다.
- **프로세스는 부모 자식 관계를 가진다.**
    - 프로세스는 부모 - 자식 관계를 가질 수 있다. 부모 프로세스는 새로운 프로세스를 생성할 수 있다.
    - 대부분의 프로세스는 부모 - 자식 관계를 가지지만, 예외적으로 부모 프로세스가 없는 경우도 존재한다.(부모 프로세스가 종료, 커널에서 생성된 프로세스 등 과 같은 프로세스)
    - **커널 프로세스(Init프로세스 등)를 제외한 나머지 프로세스는 부모 프로세스로 부터 생성**된다.
- 프로세스는 **PCB(Process Control Block)에 저장되어 운영체제에 의해 관리**된다.
    - **컨텍스트 스위칭**이 이루어지면서 프로세스가 바뀌며 CPU에 의해 처리된다.

### 프로세스의 메모리 구조

![Image](https://github.com/user-attachments/assets/11b29952-d59a-4860-892c-be8a54ed5ba6)

1. **Stack 영역**

**지역 변수, 매개 변수, 리턴 값** 등 잠시 사용되었다가 사라지는 데이터를 저장하는 영역이다. 함수 호출 시 할당되며 함수 반환 시 소멸된다. 컴파일 시점에 코드 상 필요한 메모리 크기가 미리 계산된다.

1. **Data 영역**

**전역 변수와 정적 변수**가 저장된다. 해당 변수들은 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸된다.(프로세스 생성 ~ 종료 상태 동안 저장된 상태 유지)

1. **Heap 영역**

**동적 데이터 영역(인스턴스)**으로 메모리 주소 값에 의해서 만 참조되고 사용되는 영역이다.  프로그램 동작 시(런타임)에 크기가 결정된다.

1. **Text(Code) 영역(읽기 전용 영역)**

**실행할 프로그램의 코드가 저장**된다. CPU는 해당 영역에서 명령어를 하나씩 가져와 처리한다.

### 프로세스의 상태(Process Statement)

프로세스는 컴퓨터에서 실행되고 있는 프로그램이기 때문에 상태(Statement)가 존재한다.

![Image](https://github.com/user-attachments/assets/4d862a6a-41a9-4a1d-b48e-c69a1a3544f6)

1. **생성(Create)**

운영체제에 의해 프로세스가 **생성되는 중**인 상태이다.

1. **실행(Running) - CPU할당 후**

프로세스가 CPU를 차지하여 **명령어들이 실행되는 중**이다.

1. **준비(Ready) - CPU할당 전**

프로세스가 CPU를 사용하고 있지는 않지만, 언제든지 사용할 수 있는 상태로, CPU가 할당되기를 기다리는 중이다. 준비 상태에 있는 다수의 프로세스 중 **우선순위가 높은 프로세스가 CPU를 할당받는다.**

1. **대기(Waiting or Blocked) - 신호 기다리는 중**

보류(Block)라고 부르기도 하며, 프로세스가 입출력 완료, 시그널 수신 등 어떤 사건(Event)을 기다리고 있는 상태이다.

1. **종료(Terminated)**

프로세스의 실행이 종료된 상태이다.

### 프로세스 생성 과정

1. **메모리 공간 예약(할당) 준비**
   실행 파일에 기록된 정보를 바탕으로, 실행 중 필요한 공간(코드, 데이터, 스택 등)을 계산한다.
2. **실행 파일의 메모리 적재**
   메모리 공간이 준비된 후 운영체제는 프로그램의 실행 파일을 읽고, 적절한 위치에 실행 파일을 적재한다.
3. **런타임 메모리 구조 초기화**
   프로그램 실행을 위해 추가 메모리 구조를 설정한다.
    1. **스택**: 함수, 지역 변수 저장을 위한 메모리
    2. **힙**: 동적 메모리 할당을 위한 공간(객체, malloc 등)
    3. 초기화되지 않은 데이터 섹션(`.bss` 등)
4. **프로세스 테이블 등록 및 실행 준비**
    1. 운영체제가 해당 프로세스를 프로세스 테이블에 등록
    2. 초기 CPU레지스터 상태, 프로그램 카운터, 스택 포인터 등을 설정
    3. CPU실행 준비 완료

### 상태 전이

1. **디스패치(Dispatch)**

준비 리스트의 맨 앞에 있던 프로세스가 CPU를 점유하게 되는 것으로, 준비(Ready)상태에서 실행(Running)상태로 바뀌는 것을 말한다.

1. **보류(Block)**

실행(Running)상태의 프로세스가 허가된 시간을 다 쓰기 전에 **입출력 동작을 필요로 하는 것 과 같은 사건(Event)을 필요로 하는 경우** 프로세스는 CPU를 스스로 반납하고 보류 상태로 넘어간다.

1. **깨움(Wakeup)**

**입출력 작업 종료 등 기다리던 사건(Event)이 일어났을 때** 보류 상태에서 준비 상태로 넘어가는 과정을 깨움이라고 한다.

1. **시간 제한(Timeout)**

운영체제는 프로세스가 CPU를 계속 독점해서 사용하지 못하게 하기 위해 **clock interrupt를 두어 프로세스가 일정 시간 동안만 CPU를 점유**할 수 있게 한다.

## 스레드

> 프로세스 내에서 **실행되는 흐름 단위**이다.
>

위의 정의에 따르면 프로세스의 흐름 단위는 스레드 라고 불리며 스레드는 하나의 실행 흐름 단위이기 때문에 여러 개 생겨날 수 있다.

프로그램이 실행되어 메모리에 적재되면, 적재 된 것을 프로세스라고 설명했는데 이런 프로세스 내에는 실행 흐름(스레드)이 여러 개 존재할 수 있다. 실행 흐름이 여러 개 존재하는 경우를 **멀티 스레드** 라고 부른다.

**실행 흐름이 대체 뭘까?**

영화관에서 영화를 상영하기 위해 **영화 시작 전 ~ 영화 끝 시점까지 이루어져야 할 일들을 살펴보자**.

영화를 보기 전 직원이 **영화 티켓을 확인**하고, 영화를 상영할 때 스크린에는 **영상이 플레이** 되고, 스피커에는 영화에 맞는 **음성이 나와야 한다**. 또, 영화가 끝나고 **출구를 직원이 열어줘야 한다**.

영화를 상영하기 위해서 이루어져야 할 일은 총 4가지이다.

1. **영화 티켓 확인**
2. **영화 상영**
3. **영화 음성 실행**
4. **끝나면 출구 열기**

영화 상영을 프로세스에 빗대면, 위의 4가지 일(실행 흐름)이 모여 영화 상영이라는 프로그램이 되는 것이다.

### 스레드의 특징

- **경량 프로세스이다.**
    - 스레드는 프로세스 내에서 동작하며, 독립적인 실행 흐름을 가진다.
- **프로세스 자원 공유**
    - 스레드는 같은 **프로세스 내 자원(메모리, 파일, 전역 변수 등)을 공유**한다.
- **독립적인 실행 흐름**
    - 스레드는 프로세스의 일부로, **독립적인 실행 흐름(PC, 스택, 레지스터 등)을 가진다**.
    - 여러 스레드가 동시에 실행될 수 있어 병렬 처리가 가능하다.
- **동시성 및 병렬성을 지님(중요)**
    - 하나의 프로세스 내에서 여러 스레드가 동시에 실행되며, 이를 통해 **동시성**을 구현할 수 있다.
    - 또한, **멀티코어 CPU**에서는 여러 스레드가 **병렬로 처리**될 수 있어, 성능을 향상시킬 수 있다.
- **자원 공유**
    - 스레드 간 데이터 공유가 쉬운 대신 **경쟁 상태** 혹은 **데드 락** 같은 동기화 문제가 발생할 수 있다. 이를 방지하기 위해 **뮤텍스, 세마포어, 락** 과 같은 동기화 기법이 필요하다.

### 스레드의 구성 요소

1. **스택(Stack)**

각 스레드는 함수 호출, 지역 변수 등을 관리하는 독립적인 스택 공간을 가진다**.**

1. **레지스터 및 프로그램 카운터(PC)**

현재 코드의 실행 위치와 상태를 나타낸다.

1. **공유 메모리**

같은 프로세스 내의 다른 스레드와 힙 영역, 전역 변수 등을 공유한다.

### 멀티 스레드

![Image](https://github.com/user-attachments/assets/5bab8c78-f256-4802-add8-c9880bd2a35b)

프로세스가 실행되는데 실행 흐름(스레드)이 2개 이상인 것을 말한다.

### 멀티 스레드 메모리 구조

![Image](https://github.com/user-attachments/assets/885d14bd-16ea-4621-b2ac-fff1edab1ccd)

멀티 스레드의 경우 스레드가 공유하는 자원과 공유하지 않는 자원이 존재한다.

**공유하는 자원**

- Text(Code)영역
- Data영역
- Heap영역

**공유하지 않는 자원**

- PC(Program Counter)
- SP(Stack Pointer)
- Stack영역
- 기타 레지스터

## 스레드 생성 여부 확인

스레드 생성 여부를 간단한 Java프로그램을 작성하고 생성된 스레드의 갯수를 확인해보기 위해 간단한 설정을 해보자.

### 작업 관리자 설정

1. 작업 관리자의 **세부 정보**로 들어간다.

![Image](https://github.com/user-attachments/assets/adae8017-a04d-452b-b87f-3c1d9ec880f6)

1. 이름 열에 우클릭 후 열 선택을 누른다.

![Image](https://github.com/user-attachments/assets/4c2ce53a-6b65-44b0-978e-ff86d5bd47ad)

1. 열 선택에서 **스레드**를 체크한다.

![Image](https://github.com/user-attachments/assets/f59cca15-e9ea-43a6-a714-a6ff1719aae7)

1. 결과

![Image](https://github.com/user-attachments/assets/ce6172d5-7443-4542-b50f-4c958a210888)

스레드 열이 생성된 것을 볼 수 있다.

이로써 프로세스에 몇 개의 스레드(실행 흐름)가 존재하는지 확인할 수 있다.

### 단일 스레드 동작

```java
public class Main {
    public static void main(String[] args) {
        while(true) {
            System.out.println("mainThread");
        }
    }
}
```

위와 같이 실행 시키게 되면, Java프로그램의 스레드는 몇 개 생겨날까?

**실행 후 Java.exe프로세스**

![Image](https://github.com/user-attachments/assets/4e643758-7030-484f-868e-16d38ec147fc)

IntelliJ를 통해 java.exe 실행 파일을 실행하면서 프로세스로 하나 생성된다.

위의 java.exe는 IntelliJ를 동작하기 위한 실행 파일이고, 아래의 java.exe는 작성한 코드를 동작하기 위한 실행 파일이다.

현재 싱글 스레드 프로그램의 스레드는 37개이다.

**참고)**

현재 스레드가 37개인 이유는 **GC, Main, JIT(Just In Time컴파일러), JVM내부 스레드 등이 동작하기 때문**

**참고)**

현재 스레드가 38개인 이유는 **GC, Main, JIT(Just In Time컴파일러), JVM내부 스레드 등이 동작하기 때문**

### 멀티 스레드 동작

```java
class MyThread extends Thread{
    public MyThread(){}
    @Override
    public void run() {
        while(true){
            System.out.println("thread");}
    }
}
public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
        while(true) {
            System.out.println("mainThread");
        }
    }
}
```

**실행 후**

![Image](https://github.com/user-attachments/assets/a63a2702-af71-4b1d-a9d9-2787ca5271aa)

싱글 스레드로 동작했을 때 스레드의 갯수를 비교해보면, 38개로 총 1개 늘어난 것을 볼 수 있다.

결국, java 실행 파일이 실행되고, 메모리에 적재되면서 하나의 프로세스로 `java.exe` 가 생성된 것이다. 해당 프로세스에는 총 38개의 스레드(실행 흐름)가 동작하는 것이다.